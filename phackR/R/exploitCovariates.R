# ==============================================================================
# Exploiting Covariates
# ==============================================================================

#' Simulate data with (correlated) covariates
#' @description Simulates a dependent variable that correlates with multiple (correlated) covariates as well as an independent IV
#' @param nobs.group Vector with number of observations per group
#' @param ncov Number of continuous covariates in the simulated data frame
#' @param rcov Correlation between the covariates
#' @param rcovdv Correlation between covariates and dependent variable
#' @param mu Mean of the random data
#' @param sd Standard deviation of the random data
#' @param missing Proportion of missing values per variable (e.g., 0.2 = 20 percent)
#' @importFrom stats rnorm

.sim.covariates <- function(nobs.group, ncov, rcov, rcovdv, mu = 0, sd = 1, missing = 0){

  # Observations per group and total observations
  if(length(nobs.group) == 1) nobs.group <- rep(nobs.group, 2)
  nobs <- sum(nobs.group)

  # Generate group vector
  group <- rep(1:length(nobs.group), nobs.group)

  # Set up correlation matrix
  nvar <- ncov + 1
  R <- matrix(rep(rcov, nvar**2), nrow = nvar)
  R[,1] <- rep(rcovdv, nvar)
  R[1,] <- R[,1]
  diag(R) <- rep(1, nvar)

  # transposed Cholesky decomposition of correlation matrix
  U <- t(chol(R))

  # create random noise matrix
  random.normal <- matrix(stats::rnorm(nvar*nobs, mu, sd), nrow=nvar, ncol=nobs)

  # create raw data from matrix multiplication of U and random noise
  X <- as.data.frame(t(U %*% random.normal))

  # create final simulated data matrix
  Xfull <- cbind(group, X)

  # add missing values
  if(missing > 0){
    navalues <- as.data.frame(replicate(nvar+1, sample(1:nobs, missing*nobs)))
    for(i in 1:nvar){
      X[unlist(navalues[,i]),i] <- NA
    }
  }

  return(Xfull)

}

#' P-Hacking function for multiple covariates
#' @description Outputs a p-hacked p-value and a vector of all p-values that were computed in the process
#' @param df Data frame with one group variable, one dependent variable, and one or more covariates
#' @param dv Integer defining the location of the dependent variable column
#' @param group Integer defining the location of the group variable column
#' @param covs Numeric vector defining the location of the covariate(s).
#' @param interactions Should interaction terms be added to the ANCOVA models? TRUE/FALSE
#' @param ambitious Ambitious p-hacking (smallest p value): TRUE/FALSE
#' @param alpha Significance level of the t-test
#' @importFrom car Anova
#' @importFrom stats cor aov as.formula

.covhack <- function(df, dv, group, covs, interactions = TRUE, ambitious = FALSE, alpha = 0.05){

  # Prepare data frame
  colnames(df)[group] <- "group"
  colnames(df)[dv] <- "dv"
  colnames(df)[covs] <- paste0("CV", 1:length(covs))
  df <- df[, c(dv, group, covs)]

  ps <- NULL

  # Compute correlations between covariates and dependent variable and order covariates accordingly
  dvcors <- apply(X = df[,-group], MARGIN = 2, FUN = function(x) stats::cor(x, df$dv))[-1]
  covorder <- order(dvcors, decreasing = TRUE)

  # Define ANCOVA models (add covariates in decreasing correlation with dependent variable)

  interactions <- ifelse(interactions, " * ", " + ")
  addmodels <- c("dv ~ group", rep(NA, length(covs)))
  singmodels <- c("dv ~ group", rep(NA, length(covs)))

  for(i in 1:length(covs)){
    mdl <- paste("dv ~ group", paste0("CV", covorder[i]), sep = interactions)
    singmodels[i + 1] <- mdl
  }

  for(i in 1:length(covs)){
    mdl <- paste(paste0("CV", covorder[1:i]), collapse = interactions)
    mdl <- paste("dv ~ group", mdl, sep = interactions)
    addmodels[i+1] <- mdl
  }

  models <- unique(c(singmodels, addmodels))

  # Compute ANCOVAs

  for(i in 1:length(models)){

    res <- stats::aov(stats::as.formula(models[i]), data = df)
    ps[i] <- car::Anova(res, type = 2)["group", "Pr(>F)"]

  }

  # Select p-value "ambitious" p-hacking
  if(ambitious == TRUE){

    if(min(ps) < alpha){
      p.final <- min(ps)
    } else {
      p.final <- ps[1]
    }

    # Select p-value "normal" p-hacking
  } else if (ambitious == FALSE) {

    if(min(ps) < alpha){
      p.final <- ps[which(ps < alpha)[1]]
    } else {
      p.final <- ps[1]
    }
  }

  return(list(p.final = p.final,
              ps = ps))


}

#' Simulate p-Hacking with multiple covariates
#' Outputs a matrix containing the p-hacked p-values (\code{ps.hack}) and the original p-values (\code{ps.orig}) from all iterations
#' @param nobs.group Vector with number of observations per group
#' @param ncov Number of continuous covariates in the simulated data frame
#' @param rcov Correlation between the covariates
#' @param rcovdv Correlation between covariates and dependent variable
#' @param interactions Should interaction terms be added to the ANCOVA models? TRUE/FALSE
#' @param ambitious Ambitious p-hacking (smallest p value): TRUE/FALSE
#' @param alpha Significance level of the t-test
#' @param iter Number of simulation iterations
#' @param seed Initial seed for the random process
#' @export


sim.covhack <- function(nobs.group, ncov, rcov, rcovdv, interactions = FALSE, ambitious = FALSE, alpha = 0.05, iter = 1000, seed = 1234){

  # Simulate as many datasets as desired iterations
  dat <- list()
  set.seed(seed)
  for(i in 1:iter){
    dat[[i]] <- .sim.covariates(nobs.group = nobs.group, ncov = ncov, rcov = rcov, rcovdv = rcovdv)
  }

  # Apply p-hacking procedure to each dataset
  .covhacklist <- function(x){
    .covhack(df = x, dv = 2, group = 1, covs = c(3:(2+ncov)), interactions = interactions, ambitious = ambitious, alpha = alpha)
  }

  res <- lapply(dat, .covhacklist)

  ps.hack <- NULL
  ps.orig <- NULL
  for(i in 1:iter){
    ps.hack[i] <- res[[i]][["p.final"]]
    ps.orig[i] <- res[[i]][["ps"]][1]
  }

  res <- cbind(ps.hack, ps.orig)

  return(res)


}


