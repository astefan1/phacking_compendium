# ==============================================================================
# Exploiting Covariates
# ==============================================================================

#' Simulate data with (correlated) covariates
#' @description Simulates a dependent variable that correlates with multiple (correlated) covariates as well as an independent IV
#' @param nobs.group Vector with number of observations per group
#' @param ncov Number of continuous covariates in the simulated data frame
#' @param rcov Correlation between the covariates
#' @param rcovdv Correlation between covariates and dependent variable
#' @param mu Mean of the random data
#' @param sd Standard deviation of the random data
#' @param missing Proportion of missing values per variable (e.g., 0.2 = 20 percent)
#' @importFrom stats rnorm

.sim.covariates <- function(nobs.group, ncov, rcov, rcovdv, mu = 0, sd = 1, missing = 0){

  # Observations per group and total observations
  if(length(nobs.group) == 1) nobs.group <- rep(nobs.group, 2)
  nobs <- sum(nobs.group)

  # Generate group vector
  group <- rep(1:length(nobs.group), nobs.group)

  # Set up correlation matrix
  nvar <- ncov + 1
  R <- matrix(rep(rcov, nvar**2), nrow = nvar)
  R[,1] <- rep(rcovdv, nvar)
  R[1,] <- R[,1]
  diag(R) <- rep(1, nvar)

  # transposed Cholesky decomposition of correlation matrix
  U <- t(chol(R))

  # create random noise matrix
  random.normal <- matrix(stats::rnorm(nvar*nobs, mu, sd), nrow=nvar, ncol=nobs)

  # create raw data from matrix multiplication of U and random noise
  X <- as.data.frame(t(U %*% random.normal))

  # create final simulated data matrix
  Xfull <- cbind(group, X)

  # add missing values
  if(missing > 0){
    navalues <- as.data.frame(replicate(nvar+1, sample(1:nobs, missing*nobs)))
    for(i in 1:nvar){
      X[unlist(navalues[,i]),i] <- NA
    }
  }

  return(Xfull)

}

#' P-Hacking function for multiple covariates
#' @description Outputs a p-hacked p-value and a vector of all p-values that were computed in the process
#' @param df Data frame with one group variable, one dependent variable, and one or more covariates
#' @param dv Integer defining the location of the dependent variable column
#' @param group Integer defining the location of the group variable column
#' @param covs Numeric vector defining the location of the covariate(s).
#' @param interactions Should interaction terms be added to the ANCOVA models? TRUE/FALSE
#' @param strategy String value: One out of "firstsig", "smallest", "smallest.sig"
#' @param alpha Significance level of the t-test
#' @importFrom car Anova
#' @importFrom stats cor aov as.formula

.covhack <- function(df, dv, group, covs, interactions = FALSE, strategy = "firstsig", alpha = 0.05){

  # Prepare data frame
  colnames(df)[group] <- "group"
  colnames(df)[dv] <- "dv"
  colnames(df)[covs] <- paste0("CV", 1:length(covs))
  df <- df[, c(dv, group, covs)]

  ps <- NULL
  eta2s <- NULL # partial eta^2

  # Compute correlations between covariates and dependent variable and order covariates accordingly
  dvcors <- apply(X = df[,-group], MARGIN = 2, FUN = function(x) stats::cor(x, df$dv))[-1]
  covorder <- order(dvcors, decreasing = TRUE)

  # Define ANCOVA models (add covariates in decreasing correlation with dependent variable)

  interactions <- ifelse(interactions, " * ", " + ")
  addmodels <- c("dv ~ group", rep(NA, length(covs)))
  singmodels <- c("dv ~ group", rep(NA, length(covs)))

  for(i in 1:length(covs)){
    mdl <- paste("dv ~ group", paste0("CV", covorder[i]), sep = interactions)
    singmodels[i + 1] <- mdl
  }

  for(i in 1:length(covs)){
    mdl <- paste(paste0("CV", covorder[1:i]), collapse = interactions)
    mdl <- paste("dv ~ group", mdl, sep = interactions)
    addmodels[i+1] <- mdl
  }

  models <- unique(c(singmodels, addmodels))

  # Compute ANCOVAs

  for(i in 1:length(models)){

    res <- stats::aov(stats::as.formula(models[i]), data = df)
    resanc <- car::Anova(res, type = 2)
    ps[i] <- resanc["group", "Pr(>F)"]
    eta2s[i] <- resanc["group", "Sum Sq"]/(resanc["group", "Sum Sq"] + resanc["Residuals", "Sum Sq"])

  }

  # Select final p-hacked p-value based on strategy
  p.final <- .selectpvalue(ps = ps, strategy = strategy, alpha = alpha)
  eta2.final <- unique(eta2s[ps == p.final])

  return(list(p.final = p.final,
              ps = ps,
              eta2.final = eta2.final,
              eta2s = eta2s))


}

#' Simulate p-Hacking with multiple covariates
#' Outputs a matrix containing the p-hacked p-values (\code{ps.hack}) and the original p-values (\code{ps.orig}) from all iterations
#' @param nobs.group Vector with number of observations per group
#' @param ncov Number of continuous covariates in the simulated data frame
#' @param rcov Correlation between the covariates
#' @param rcovdv Correlation between covariates and dependent variable
#' @param interactions Should interaction terms be added to the ANCOVA models? TRUE/FALSE
#' @param strategy String value: One out of "firstsig", "smallest", "smallest.sig"
#' @param alpha Significance level of the t-test
#' @param iter Number of simulation iterations
#' @param shinyEnv Is the function run in a Shiny session? TRUE/FALSE
#' @export


sim.covhack <- function(nobs.group, ncov, rcov, rcovdv, interactions = FALSE, strategy = "firstsig", alpha = 0.05, iter = 1000, shinyEnv = FALSE){

  # Simulate as many datasets as desired iterations
  dat <- list()
  for(i in 1:iter){
    dat[[i]] <- .sim.covariates(nobs.group = nobs.group, ncov = ncov, rcov = rcov, rcovdv = rcovdv)
  }

  # Apply p-hacking procedure to each dataset
  if(!shinyEnv){
    .covhacklist <- function(x){
      .covhack(df = x, dv = 2, group = 1, covs = c(3:(2+ncov)), interactions = interactions, strategy = strategy, alpha = alpha)
    }

    res <- pbapply::pblapply(dat, .covhacklist)
  }

  if(shinyEnv){
    percentage <- 0
    withProgress(message = "Running simulation", value = 0, {
      res = lapply(dat, function(x){
        percentage <<- percentage + 1/length(dat)*100
        incProgress(1/length(dat), detail = paste0("Progress: ",round(percentage,2), "%"))
        .covhack(df = x, dv = 2, group = 1, covs = c(3:(2+ncov)), interactions = interactions, strategy = strategy, alpha = alpha)
      })
    })
  }

  ps.hack <- NULL
  ps.orig <- NULL
  eta2s.hack <- NULL
  eta2s.orig <- NULL

  for(i in 1:iter){
    ps.hack[i] <- res[[i]][["p.final"]]
    ps.orig[i] <- res[[i]][["ps"]][1]
    eta2s.hack[i] <- res[[i]][["eta2.final"]]
    eta2s.orig[i] <- res[[i]][["eta2s"]][1]
  }

  res <- cbind(ps.hack, ps.orig, eta2s.hack, eta2s.orig)

  return(res)


}


