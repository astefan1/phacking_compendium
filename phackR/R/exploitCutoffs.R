# ==============================================================================
# Exploiting arbitrary cutoff values
# ==============================================================================

# Simulation can be done with .sim.multcor where the correlation is zero

#' P-Hacking function for exploiting cutoff values
#' @param df Data frame with one continuous independent variable and one continuous dependent variable
#' @param iv Location of the independent variable in the data frame
#' @param dv Location of the dependent variable in the data frame
#' @param strategy String value: One out of "firstsig", "smallest", "smallest.sig"
#' @param alpha Significance level of the t-test
#' @importFrom stats t.test aov median quantile

.cutoffHack <- function(df, iv, dv, strategy = "firstsig", alpha = 0.05){

  iv <- df[, iv]
  dv <- df[, dv]

  mod.orig <- summary(stats::lm(dv ~ iv))
  p.orig <- mod.orig$coefficients[2, 4]
  r2.orig <- mod.orig$r.squared

  # Do the mediansplit
  mediansplitvar <- as.numeric(iv > stats::median(iv)) + 1
  p.mediansplit <- stats::t.test(dv[mediansplitvar == 1], dv[mediansplitvar == 2],
                          var.equal = TRUE, alternative = "two.sided")$p.value
  r2.mediansplit <- .compR2t(dv[mediansplitvar == 1], dv[mediansplitvar == 2])

  # Cut the middle
  tertiles <- as.numeric(stats::quantile(iv, probs = c(1/3, 2/3)))
  threecut <- cut(iv, breaks = c(-Inf, tertiles, Inf), labels = c(1,0,2))
  dv2 <- dv[threecut %in% c(1,2)]
  threecut2 <- threecut[threecut %in% c(1, 2)]
  p.cutmiddle <- stats::t.test(dv2[threecut2 == 2], dv2[threecut2 == 1],
                        var.equal = TRUE, alternative = "two.sided")$p.value
  r2.cutmiddle <- .compR2t(dv2[threecut2 == 2], dv2[threecut2 == 1])

  # 3 Categories: Omnibus test
  mod.threecat <- summary(stats::aov(dv ~ threecut))
  p.threecat <- mod.threecat[[1]][[5]][1]
  r2.threecat <- mod.threecat[[1]][1,2]/sum(mod.threecat[[1]][,2])

  ps <- c(p.orig, p.mediansplit, p.cutmiddle, p.threecat)
  r2s <- c(r2.orig, r2.mediansplit, r2.cutmiddle, r2.threecat)

  # Select final p-hacked p-value based on strategy
  p.final <- .selectpvalue(ps = ps, strategy = strategy, alpha = alpha)
  r2.final <- r2s[ps == p.final]

  return(list(p.final = p.final,
              ps = ps,
              r2.final = r2.final,
              r2s = r2s))

}

#' Simulate p-Hacking for exploiting cutoff values
#' Outputs a matrix containing the p-hacked p-values (\code{ps.hack}) and the original p-values (\code{ps.orig}) from all iterations
#' @param nobs Number of observations
#' @param strategy String value: One out of "firstsig", "smallest", "smallest.sig"
#' @param alpha Significance level of the t-test
#' @param iter Number of simulation iterations
#' @param shinyEnv Is the function run in a Shiny session? TRUE/FALSE
#' @export

sim.cutoffHack <- function(nobs, strategy = "firstsig", alpha = 0.05, iter = 1000, shinyEnv = FALSE){

  dat <- list()
  for(i in 1:iter){
    dat[[i]] <- .sim.multcor(nobs = nobs, nvar = 2, r = 0)
  }

  # Apply p-hacking procedure to each dataset

  if(!shinyEnv){
    .cutoffHackList <- function(x){
      .cutoffHack(df = x, iv = 1, dv = 2, strategy = strategy, alpha = alpha)
    }

    res <- pbapply::pblapply(dat, .cutoffHackList)
  }

  if(shinyEnv){
    percentage <- 0
    withProgress(message = "Running simulation", value = 0, {
      res = lapply(dat, function(x){
        percentage <<- percentage + 1/length(dat)*100
        incProgress(1/length(dat), detail = paste0("Progress: ",round(percentage,2)))
        .cutoffHack(df = x, iv = 1, dv = 2, strategy = strategy, alpha = alpha)
      })
    })
  }

  ps.hack <- NULL
  ps.orig <- NULL
  r2s.hack <- NULL
  r2s.orig <- NULL

  for(i in 1:iter){
    ps.hack[i] <- res[[i]][["p.final"]]
    ps.orig[i] <- res[[i]][["ps"]][1]
    r2s.hack[i] <- res[[i]][["r2.final"]]
    r2s.orig[i] <- res[[i]][["r2s"]][1]
  }

  res <- cbind(ps.hack, ps.orig, r2s.hack, r2s.orig)

  return(res)



}
